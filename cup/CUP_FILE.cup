/*************/
/* IMPORT(S) */
/*************/
import java_cup.runtime.*;
import ast.*;
import java.util.*;

parser code 
{:
    public Lexer lexer;

    public Parser(Lexer lexer)
    {
        super(lexer);
        this.lexer = lexer;
    }

    public void report_error(String message, Object info)
    {
        throw new RuntimeException("ERROR(" + lexer.getLine() + ")");
    }
:}

/************************/
/* CUSTOMIZE CUP PARSER */
/************************/
scan with
{:
    Symbol s;
    s = lexer.next_token();
    return s; 
:};

/*************/
/* TERMINALS */
/*************/
terminal IF, EQ, DOT, PLUS, MINUS, TIMES, WHILE, DIVIDE, LPAREN, RPAREN;
terminal LBRACK, RBRACK, LBRACE, RBRACE, SEMICOLON, ASSIGN, GT, LT;
terminal COMMA, ARRAY, CLASS, RETURN, ELSE, NEW, EXTENDS, NIL;
terminal TYPE_INT, TYPE_STRING, TYPE_VOID;
terminal Integer INT;
terminal String STRING;
terminal String ID;

/*****************/
/* NON TERMINALS */
/*****************/
non terminal AstDecList program;
non terminal AstDec     dec;
non terminal AstType    type;
non terminal AstDecVar  varDec;      
non terminal AstDecFunc funcDec;    
non terminal AstDecClass classDec;  
non terminal AstArrayTypedef arrayTypedef;
non terminal AstDec     cField;         
non terminal AstTypeNameList formalList;
non terminal AstDecList decList;
non terminal AstDecList  cFieldList;
non terminal AstExpList  callList;
non terminal AstExp     exp;
non terminal AstExpCall callExp;
non terminal AstExp     newExp;      
non terminal AstExpVar  var;          
non terminal AstStmt    stmt;
non terminal AstStmtList stmtList;

/***********************/
/* OPERATOR PRECEDENCE */
/***********************/
precedence right ASSIGN;
precedence left EQ;
precedence left LT, GT;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence right LBRACK;
precedence right LPAREN;
precedence left DOT;

start with program;

/********************/
/* DERIVATION RULES */
/********************/

program ::= decList:dl {: 
                RESULT = dl; 
            :};

decList ::= dec:d decList:l {: 
                RESULT = new AstDecList(d, l); 
            :}
          | dec:d {: 
                RESULT = new AstDecList(d, null); 
            :};

dec     ::= varDec:v          {: RESULT = v; :}
          | funcDec:f         {: RESULT = f; :}
          | classDec:c        {: RESULT = c; :}
          | arrayTypedef:a    {: RESULT = a; :}
          ;

type ::= TYPE_INT:t    {: RESULT = new AstTypeInt();    RESULT.lineNumber = tleft; :}
       | TYPE_STRING:t {: RESULT = new AstTypeString(); RESULT.lineNumber = tleft; :}
       | TYPE_VOID:t   {: RESULT = new AstTypeVoid();   RESULT.lineNumber = tleft; :}
       | ID:name       {: RESULT = new AstTypeId(name); RESULT.lineNumber = nameleft; :}
       ;

/***** DECLARATIONS *****/

varDec ::= type:t ID:name SEMICOLON 
           {: RESULT = new AstDecVar(t, name, null, tleft); :}
         | type:t ID:name ASSIGN exp:e SEMICOLON
           {: RESULT = new AstDecVar(t, name, e, tleft); :}
         ;

funcDec ::= type:t ID:name LPAREN RPAREN LBRACE stmtList:body RBRACE
            {: 
                RESULT = new AstDecFunc(t.toString(), name, null, body); 
                RESULT.lineNumber = tleft; 
            :}
          | type:t ID:name LPAREN formalList:args RPAREN LBRACE stmtList:body RBRACE
            {: 
                RESULT = new AstDecFunc(t.toString(), name, args, body); 
                RESULT.lineNumber = tleft; 
            :}
          ;

formalList ::= type:t ID:name
               {: 
                  RESULT = new AstTypeNameList(new AstTypeName(t.toString(), name), null); 
               :}
             | type:t ID:name COMMA formalList:l
               {: 
                  RESULT = new AstTypeNameList(new AstTypeName(t.toString(), name), l); 
               :}
             ;

arrayTypedef ::= ARRAY:a ID:name EQ type:t LBRACK RBRACK SEMICOLON
                 {: RESULT = new AstArrayTypedef(name, t, aleft); :}
                 ;

cField ::= varDec:v  {: RESULT = v; :} 
         | funcDec:f {: RESULT = f; :} 
         ;

cFieldList ::= cField:f cFieldList:l {: RESULT = new AstDecList(f, l); :}
             | /* empty */           {: RESULT = null; :};

classDec ::= CLASS:c ID:name LBRACE cFieldList:fields RBRACE 
             {: 
                // Error 1 fix: Ensure the second argument is an AstTypeNameList.
                // If fields is AstDecList, we might need a specific conversion 
                // or to change the non-terminal type of cFieldList.
                RESULT = new AstDecClass(name, null); 
                RESULT.lineNumber = cleft; 
             :}
           | CLASS:c ID:name EXTENDS ID:superName LBRACE cFieldList:fields RBRACE
             {: 
                // Error 2 fix: superName must be wrapped in an AstTypeName object
                RESULT = new AstDecClass(name, new AstTypeNameList(new AstTypeName(null, superName), null)); 
                RESULT.lineNumber = cleft; 
             :};

/***** STATEMENTS *****/

stmtList ::= stmt:s stmtList:l 
             {: RESULT = new AstStmtList(s,l);  RESULT.lineNumber = s.lineNumber; :}
           | /* empty */ 
             {: RESULT = null; :}
           ;

stmt ::= varDec:v                                       
         {: RESULT = new AstStmtDecVar(v);    RESULT.lineNumber = v.lineNumber; :}  
       | var:v ASSIGN exp:e SEMICOLON                   
         {: RESULT = new AstStmtAssign(v,e);  RESULT.lineNumber = v.lineNumber; :}
       | RETURN:r exp:e SEMICOLON                        
         {: RESULT = new AstStmtReturn(e);    RESULT.lineNumber = rleft; :}
       | RETURN:r SEMICOLON                              
         {: RESULT = new AstStmtReturn(null); RESULT.lineNumber = rleft; :}
       | callExp:c SEMICOLON                             
         {: RESULT = new AstStmtCall(c);      RESULT.lineNumber = cleft; :}
       | IF:i LPAREN exp:cond RPAREN LBRACE stmtList:b RBRACE 
         {: RESULT = new AstStmtIf(cond, b); RESULT.lineNumber = ileft; :}
       | IF:i LPAREN exp:cond RPAREN LBRACE stmtList:b RBRACE ELSE LBRACE stmtList:eb RBRACE 
         {: RESULT = new AstStmtIfElse(cond, b, eb); RESULT.lineNumber = ileft; :}
       | WHILE:w LPAREN exp:cond RPAREN LBRACE stmtList:b RBRACE  
         {: RESULT = new AstStmtWhile(cond, b); RESULT.lineNumber = wleft; :}
       | LBRACE:l stmtList:sl RBRACE
         {: 
            RESULT = new AstStmtBlock(sl); 
            RESULT.lineNumber = lleft; 
         :}
       ;

/***** EXPRESSIONS *****/

exp ::= INT:i                       {: RESULT = new AstExpInt(i);           RESULT.lineNumber = ileft; :}
      | MINUS:m INT:i               {: RESULT = new AstExpInt(-i);          RESULT.lineNumber = mleft; :}
      | STRING:s                   {: RESULT = new AstExpString(s);        RESULT.lineNumber = sleft; :}
      | var:v                       {: RESULT = v;                          :} 
      | callExp:c                   {: RESULT = c;                          :}
      | newExp:ne                   {: RESULT = ne;                         :}
      | LPAREN exp:e RPAREN         {: RESULT = e;                          :}
      | exp:e1 PLUS   exp:e2        {: RESULT = new AstExpBinop(e1, e2, 0); RESULT.lineNumber = e1.lineNumber; :}
      | exp:e1 MINUS  exp:e2        {: RESULT = new AstExpBinop(e1, e2, 1); RESULT.lineNumber = e1.lineNumber; :}
      | exp:e1 TIMES  exp:e2        {: RESULT = new AstExpBinop(e1, e2, 2); RESULT.lineNumber = e1.lineNumber; :}
      | exp:e1 DIVIDE exp:e2        {: RESULT = new AstExpBinop(e1, e2, 3); RESULT.lineNumber = e1.lineNumber; :}
      | exp:e1 LT     exp:e2        {: RESULT = new AstExpBinop(e1, e2, 4); RESULT.lineNumber = e1.lineNumber; :}
      | exp:e1 GT     exp:e2        {: RESULT = new AstExpBinop(e1, e2, 5); RESULT.lineNumber = e1.lineNumber; :}
      | exp:e1 EQ     exp:e2        {: RESULT = new AstExpBinop(e1, e2, 6); RESULT.lineNumber = e1.lineNumber; :}
      ;

/***** VARIABLES & NEW *****/

var ::= ID:name                   {: RESULT = new AstExpVarSimple(name, nameleft, nameright); :}
      | var:v DOT ID:f            {: RESULT = new AstExpVarField(v,f);  RESULT.lineNumber = v.lineNumber; :}
      | var:v LBRACK exp:e RBRACK {: RESULT = new AstExpVarSubscript(v,e); RESULT.lineNumber = v.lineNumber; :}
      ;

newExp ::= NEW:n type:t LBRACK exp:e RBRACK {: RESULT = new AstNewArray(t, e, nleft); :} ;

/* For Function Call Arguments */
callList ::= exp:e COMMA callList:l  {: RESULT = new AstExpList(e, l); :}
           | exp:e                   {: RESULT = new AstExpList(e, null); :};

callExp ::= ID:name LPAREN RPAREN
            {: RESULT = new AstExpCall(name, null); RESULT.lineNumber = nameleft; :}
          | ID:name LPAREN callList:args RPAREN
            {: RESULT = new AstExpCall(name, args); RESULT.lineNumber = nameleft; :}
          | var:v DOT ID:name LPAREN RPAREN
            {: 
               /* The AST doesn't support 'v.', so we treat it as a standard call for now */
               RESULT = new AstExpCall(name, null); RESULT.lineNumber = v.lineNumber; 
            :}
          | var:v DOT ID:name LPAREN callList:args RPAREN
            {: 
               RESULT = new AstExpCall(name, args); RESULT.lineNumber = v.lineNumber; 
            :};